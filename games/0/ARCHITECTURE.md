# Архитектура игры Lane Runner

## Общая структура

Игра состоит из 4 основных классов:
1. **GameActivity** - игровая активность, управляет жизненным циклом и запуском игры
2. **GameView** - основной игровой компонент (логика и отрисовка)
3. **Player** - класс игрока
4. **Obstacle** - класс препятствий

---

## 1. GameActivity.kt

**Назначение:** Игровая активность, управляет жизненным циклом игры и фоновой музыкой

### Основные компоненты:

```kotlin
class GameActivity : AppCompatActivity()
private lateinit var gameView: GameView
private var backgroundMusic: MediaPlayer? = null
```

### Что делает:

1. **Инициализация** (`onCreate`)
   - Получает параметры из Intent (laneCount, frequency), если они переданы
   - Создает GameView
   - Настраивает параметры игры через `setGameParameters()`
   - Устанавливает Timed Game Mode через `setTimedGameMode()`
   - Настраивает полноэкранный режим
   - Инициализирует фоновую музыку
   - Устанавливает MusicController для GameView

2. **Управление музыкой:**
   - `initializeMusic()` - загружает музыку из `res/raw/background_music.*`
   - `pauseBackgroundMusic()` - ставит музыку на паузу
   - `resumeBackgroundMusic()` - возобновляет музыку
   - Музыка зациклена (`isLooping = true`)

3. **Жизненный цикл:**
   - `onResume()` - возобновляет игру и музыку (если игра не на паузе)
   - `onPause()` - ставит игру и музыку на паузу
   - `onDestroy()` - освобождает ресурсы MediaPlayer

4. **Интерфейс MusicController:**
   - Позволяет GameView управлять музыкой
   - GameView может ставить музыку на паузу при столкновении

### Поток данных:
```
GameActivity → GameView
GameActivity ← MusicController ← GameView
```

**Примечание:** GameActivity является точкой входа в игру. Параметры игры (количество полос, частота) могут передаваться через Intent или устанавливаться по умолчанию.

---

## 2. GameView.kt

**Назначение:** Главный компонент игры - содержит всю игровую логику и отрисовку

### Основные компоненты:

#### Переменные состояния:
- `player: Player` - игрок
- `obstacles: CopyOnWriteArrayList<Obstacle>` - список препятствий (thread-safe)
- `laneCount: Int` - текущее количество полос
- `lanePositions: List<Float>` - позиции полос на экране
- `score: Int` - текущий счет
- `bestScore: Int` - лучший счет (из SharedPreferences)
- `gameOver: Boolean` - флаг окончания игры
- `isPaused: Boolean` - флаг паузы

#### Игровой цикл:
- `gameLoopThread: Thread` - отдельный поток для игрового цикла
- `isRunning: Boolean` - флаг работы цикла
- `frameCount: Int` - счетчик кадров

#### Аудио/вибрация:
- `soundPool: SoundPool?` - для звука столкновения
- `vibrator: Vibrator?` - для вибрации при столкновении

### Основные методы:

#### 1. Инициализация (`onSizeChanged`)
```kotlin
override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int)
```
- Вызывается при изменении размера View
- Инициализирует игрока
- Вычисляет позиции полос
- Загружает звук столкновения
- Инициализирует вибратор

#### 2. Игровой цикл (`resume`, `pause`, `update`)

**resume():**
- Запускает отдельный поток
- В цикле вызывает `update()` и `postInvalidate()`
- Работает с частотой ~60 FPS (Thread.sleep(16))

**update():**
- Увеличивает счетчик кадров
- Спавнит препятствия по частоте
- Обновляет игрока и препятствия
- Удаляет препятствия, вышедшие за экран
- Проверяет столкновения
- Управляет таймерами замедления/ускорения
- Обрабатывает изменение количества полос (Timed Mode)

**pause():**
- Останавливает игровой цикл
- Ждет завершения потока

#### 3. Спавн препятствий (`spawnObstacle`)

**Логика:**
1. Определяет, в каких полосах спавнить препятствия
2. Гарантирует, что не все полосы заняты одновременно
3. Выбирает случайные полосы
4. Для каждого препятствия:
   - Определяет тип (NORMAL или специальный)
   - Создает Obstacle
   - Применяет эффекты замедления/ускорения
   - Добавляет в список

**Разблокировка типов:**
- Зависит от очков (score)
- 0-4 очка: только NORMAL
- 5+ очков: FAST
- 10+ очков: SLOW
- 15+ очков: SMALL
- 20+ очков: BIG
- 25+ очков: LANE_CHANGER

#### 4. Обработка касаний (`onTouchEvent`)

**ACTION_DOWN:**
- Если Game Over → перезапуск
- Если тап в правом верхнем углу → пауза/возобновление
- Иначе → сохраняет начальную позицию (startX, startY)

**ACTION_UP:**
- Вычисляет дельту движения (deltaX, deltaY)
- Если движение < 50px → **тап:**
  - Левая половина экрана → moveLeft()
  - Правая половина экрана → moveRight()
- Если движение ≥ 50px → **свайп:**
  - Горизонтальный свайп → moveLeft/moveRight
  - Вертикальный свайп → slowDown/speedUp

#### 5. Проверка столкновений (`checkCollisions`)

**Логика:**
- Для каждого препятствия вычисляет зону столкновения
- Зона находится в нижней части препятствия (более справедливо)
- Если пересекается с игроком:
  - Устанавливает gameOver = true
  - Сохраняет лучший счет
  - Вызывает вибрацию
  - Воспроизводит звук столкновения
  - Ставит музыку на паузу
  - Ставит игру на паузу

#### 6. Отрисовка (`onDraw`)

**Что рисуется:**
1. Белый фон
2. Линии полос (с анимацией при изменении количества)
3. Игрок (player.draw())
4. Препятствия (obstacle.draw() для каждого)
5. Счет и лучший счет
6. Кнопка паузы
7. "Game Over" или "Paused" текст

**Анимация полос:**
- При изменении количества полос используется плавная интерполяция
- Ease-in-out эффект через косинус
- Длительность: 1500ms

#### 7. Управление скоростью препятствий

**slowDownObstacles():**
- Устанавливает slowdownActive = true
- Замедляет все препятствия на 7 единиц
- Действует 2 секунды

**speedUpObstacles():**
- Устанавливает speedupActive = true
- Ускоряет все препятствия на 5 единиц
- Действует 2 секунды

**Важно:** Во время замедления новые препятствия не спавнятся!

#### 8. Timed Game Mode

**Логика изменения полос:**
- Каждые 15 секунд количество полос меняется
- 3 → 4 → 5 → 6 → 7 → 6 → 5 → 4 → 3...
- При уменьшении полос скорость препятствий увеличивается
- За 4 секунды до изменения спавн останавливается
- Используется плавная анимация перехода

---

## 3. Player.kt

**Назначение:** Представляет игрока на экране

### Основные компоненты:

```kotlin
class Player(private val screenHeight: Int, private var lanePositions: List<Float>)
```

#### Переменные:
- `rect: RectF` - прямоугольник игрока (для коллизий)
- `currentLane: Int` - текущая полоса (индекс)
- `walkAnimationPhase: Float` - фаза анимации ходьбы (0 до 2π)

#### Paint объекты:
- `bodyPaint` - для тела и головы (FILL)
- `limbPaint` - для рук и ног (STROKE)
- `hairPaint` - для волос (STROKE)
- `bodyPath` - Path для тела (переиспользуется)

### Основные методы:

#### 1. Инициализация (`init`)
- Вычисляет начальную позицию (центр по X, 75% высоты по Y)
- Создает RectF размером 200x200

#### 2. Обновление (`update`)
- Обновляет анимацию ходьбы
- Каждые 70ms увеличивает фазу на 0.45
- Использует синусоиду для плавной анимации

#### 3. Движение (`moveLeft`, `moveRight`)
- Проверяет границы (не выходит за пределы)
- Изменяет currentLane
- Обновляет позицию через `updatePosition()`

#### 4. Отрисовка (`draw`)

**Что рисуется:**
1. **Голова** - круг сверху
2. **Волосы** - дуга на голове
3. **Тело** - трапеция (шире в плечах, уже в талии)
4. **Руки** - две линии (плечо-локоть-кисть)
5. **Ноги** - две линии (бедро-колено-стопа)

**Анимация:**
- Использует `sin(walkAnimationPhase)` для движения рук/ног
- Левая рука и правая нога движутся вместе
- Правая рука и левая нога движутся вместе
- Амплитуда: 25px для рук, 17.5px для ног

#### 5. Обновление позиций полос (`updateLanePositions`)
- Вызывается при изменении количества полос
- Вычисляет относительную позицию
- Сохраняет позицию игрока при изменении полос

---

## 4. Obstacle.kt

**Назначение:** Представляет препятствие на экране

### Основные компоненты:

```kotlin
enum class ObstacleType {
    NORMAL, FAST, SLOW, BIG, SMALL, LANE_CHANGER
}

class Obstacle(x: Float, y: Float, val type: ObstacleType, speedBoost: Float, lanePositions: List<Float>?)
```

#### Переменные:
- `rect: RectF` - прямоугольник препятствия
- `type: ObstacleType` - тип препятствия
- `speed: Float` - текущая скорость
- `originalSpeed: Float` - исходная скорость
- `sizeMultiplier: Float` - множитель размера (для BIG/SMALL)
- `walkAnimationPhase: Float` - фаза анимации ходьбы
- `currentLaneIndex: Int` - текущая полоса (для LANE_CHANGER)
- `lastLaneChangeTime: Long` - время последней смены полосы

### Основные методы:

#### 1. Инициализация (`init`)

**Размер:**
- BIG: 1.5x (150px)
- SMALL: 0.7x (70px)
- Остальные: 1.0x (100px)

**Скорость:**
- FAST: 12-14
- SLOW: 6-8
- BIG: 7-9
- SMALL: 10-12
- LANE_CHANGER: 8-10
- NORMAL: 8

**Для LANE_CHANGER:**
- Находит начальную полосу по позиции X
- Сохраняет lanePositions для смены полос

#### 2. Обновление (`update`)

**Движение:**
- Увеличивает rect.top и rect.bottom на speed
- Препятствие движется вниз

**Анимация:**
- Обновляет фазу ходьбы каждые 70ms
- Амплитуда меньше, чем у игрока (15px vs 25px)

**Смена полос (LANE_CHANGER):**
- Каждые 2 секунды меняет полосу случайным образом
- Обновляет позицию X препятствия

#### 3. Управление скоростью

**slowDown():**
- Уменьшает скорость на 7 единиц
- Минимум: 1

**speedUp():**
- Увеличивает скорость на 5 единиц

**restoreSpeed():**
- Восстанавливает исходную скорость

#### 4. Отрисовка (`draw`)

**Базовая отрисовка (как у игрока):**
- Голова, волосы, тело, руки, ноги

**Визуальные индикаторы:**
- **FAST:** маленькие линии по бокам головы
- **SLOW:** горизонтальная линия над головой
- **LANE_CHANGER:** стрелки по бокам

**Размеры:**
- Все размеры масштабируются через sizeMultiplier
- Толщина линий также масштабируется

---

## Поток выполнения игры

### 1. Запуск:
```
GameActivity.onCreate() → GameView создается → GameView.onSizeChanged()
```

### 2. Игровой цикл (каждый кадр):
```
GameView.resume() → Thread → update() → postInvalidate() → onDraw()
```

### 3. Обновление (update):
```
1. frameCount++
2. spawnObstacle() (если нужно)
3. player.update()
4. obstacles.forEach { it.update() }
5. obstacles.removeAll { ушли за экран }
6. checkCollisions()
7. Управление таймерами
8. Обработка изменения полос (Timed Mode)
```

### 4. Отрисовка (onDraw):
```
1. Белый фон
2. Линии полос
3. player.draw()
4. obstacles.forEach { it.draw() }
5. Текст (счет, пауза, game over)
6. Кнопка паузы
```

### 5. Обработка касаний:
```
onTouchEvent() → ACTION_DOWN → ACTION_UP → 
  → Тап: moveLeft/moveRight
  → Свайп: moveLeft/moveRight/slowDown/speedUp
```

---

## Ключевые концепции

### 1. Thread-based game loop
- Игровой цикл работает в отдельном потоке
- Это позволяет игре работать независимо от UI потока
- Частота: ~60 FPS (16ms на кадр)

### 2. CopyOnWriteArrayList
- Thread-safe список для препятствий
- Позволяет безопасно изменять список из разных потоков

### 3. Программная отрисовка
- Все объекты рисуются через Canvas API
- Не используются bitmap ресурсы
- Paint объекты переиспользуются для производительности

### 4. Анимация через синусоиду
- Используется `sin(phase)` для плавной анимации
- Фаза увеличивается со временем
- Создает эффект ходьбы

### 5. Система разблокировки
- Типы препятствий разблокируются по очкам
- Используется для постепенного увеличения сложности

### 6. Умный спавн
- Гарантирует, что не все полосы заняты
- Только одно специальное препятствие на спавн
- Во время замедления спавн останавливается

---

## Оптимизации производительности

1. **Переиспользование Paint объектов** - создаются один раз, не каждый кадр
2. **Переиспользование Path объектов** - используется reset() вместо создания нового
3. **Оптимизированные вычисления** - простые циклы вместо minByOrNull
4. **Кэширование вычислений** - позиции полос вычисляются один раз

---

## Зависимости между классами

```
GameActivity
    ↓ (создает)
GameView
    ↓ (создает и управляет)
Player + Obstacle[]
```

**GameView** - центральный компонент, координирует все остальные классы.

**GameActivity** - точка входа в приложение, управляет жизненным циклом и музыкой.

